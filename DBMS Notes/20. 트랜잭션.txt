1. 트랜잭션(Transaction)
    0) DBMS에서 논리적 연산 단위임.                              //- 상호작용의 한 단위.
        - 더이상 나눌수 없는 작업의 단위
            - 분할할 수 없는 최소의 단위
                - 전부 적용하거나 전부 취소함
                - Transaction 은 ALL or NOTHING 의 개념임.
        - INSERT, UPDATE, SELECT, DELETE 가 각 하나의 트랜잭션.
        - 하나의 트랜잭션에는 하나 이상의 SQL 문장이 포함됨.
    1) 데이터베이스 내에 읽거나 쓰는 여러 개 쿼리를 요구함
    2) 예를 들면, 이체를 할때 한 계좌에서 인출되면 다른 계좌에서 입금이 확인되는 것이 중요함.
        - 출금(UPDATE) -> 돈 -> 입금(UPDATE)이 하나의 Tx(트랜잭션)로 묶여야 함.
    3) 만약 쿼리 하나가 실패하면, DBMS은 전체 트랜잭션 또는 실패한 쿼리를 롤백함.
        - 개발방식에 따라 다름.
            - '모' 아니면 '도' (둘 다 성공하던가, 하나만 실패해도 전부 취소)
        - 트랜잭션은 Commit 전에 언제든지 수동으로 Rollback 될수 있음.

    4) AOP와 비슷.

2. 트랜잭션의 4대 특징 (ACID)
    1) 원자성 (Atomicity)
        - 나눌 수 없는 하나의 작업으로 다뤄져야 함
        - 트랜잭션에서 정의된 연산들은 모두 성공적으로 끝나거나 모두 실패해야 함.        //- 데이터 조작이 전부 성공 혹은 실패할지 보증하는 구조
        - COMMIT    : 조작 과정에 문제 없으면 처리 확정
                      작업 내용을 DB 에 영구적으로 저장
        - ROLLBACK  : 조작 중간에 문제 발생 시 마지막 커밋으로 복귀
                      최근 변경사항을 취소

    2) 일관성 (Consistency)
        - 트랜잭션이 실행되기 전의 데이터베이스의 내용이 잘못되어 있지 않다면 
          실행된 이후에서 데이터베이스의 내용에 잘못이 있으면 안됨.
        - 데이터 조작 전후에 일관성 유지 필요
            - Tx 수행 전과 후가 일관된 상태를 유지해야 함
        - 예) 회원 가입 시 등록번호에 유일성 제약 설정

    3) 고립성(격리성) (Isolation)
        - 각각의 Tx 는 독립적으로 수행되어야 함
        - 복수 사용자가 동시에 데이터 조작 실행할 경우 각각의 처리가 모순없이 실행되는 것을 보증.
        - 데이터베이스 오브젝트에 대해 잠금을 걸어 후속 처리 차단
            - Isolation Level 너무 높으면 다른 작업을 하는 사람은 기다려야하는 상황발생
        - 직렬화 가능 기능 (직렬 상태로 복수 트랜잭션 순서대로 처리)
            - DBMS내에서 트랜잭션 격리 수준 설정으로 구현
        - 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안됨.
    
    4) 지속성 (Durablity)
        - 성공한 Tx 의 결과는 유지되어야 함.
        - 데이터 조작 완료 후 완료 통지 받는 시점에서 결과 잃지 않는 것
        - 트랜잭션이 Commit 되고나면 데이터 변경 사항이 영구적으로 확정되도록 보장하는 것. 

3. COMMIT
    1) 입력한 자료나 수정한 자료에 대해서 또는 삭제한 자료에 대해서
       전혀 문제가 없다고 판단되었을 경우 COMMIT 명령어를 통해서 
       트랜잭션을 완료할 수 있음.
    2) COMMIT 이나 ROLLBACK 이전의 데이터 상태
        - 단지 메모리 BUFFER 에만 영향을 받았기 떄문에
          데이터의 변경 이전 상태로 복구 가능함.
        - 현재 사용자는 SELECT 문장으로 결과를 확인 가능함.
        - 다른 사용자는 현재 사용자가 수행한 명령의 결과를 볼수 없음.
        - 변경된 행은 잠금 (LOCKING)이 설정되어서 다른 사용자가 변경할 수 없음.
    3) COMMIT 이후의 상태
        - 데이터에 대한 변경 사항이 데이터베이스에 반영됨.
        - 이전 데이터는 영원히 잃어버리게 됨.
        - 모든 사용자는 결과를 볼수 있음.
        - 관련된 행에 대한 잠금(LOCKING)이 풀리고, 다른 사용자들이 행을 조작할수 있게 됨.

4.ROLLBACK
    1) 테이블 내 입력한 데이터나, 수정한 데이터나, 삭제한 데이터에 대하여
          COMMIT 이전에는 변경 사항을 취소할 수 없음
    2) 데이터베이스에서는 롤백(ROLLBACK) 기능을 사용함
    3) 데이터 변경 사항이 취소되어 데이터의 이전 상태로 복구되며, 관련된 행에 대한 잠금(LOCKING)이 풀리고 
        다른 사용자들이 데이터 변경을 할 수 있게 됨.
5. SAVE POINT
    1) 저장점을 정의하면 롤백할 떄 트랜잭션에 포함된 전체 작업을 롤백하는 것이 아니라
          현 시점에서 SAVE POINT 까지 트랜잭션의 일부만 롤백할수 있음.
    2) 복잡한 대규모 트랜잭션에서 에러가 발생했을 때 SAVE POINT 까지의 트랜잭션만 롤백하고
          실패한 부분에 대해서만 다시 실행.

6. 자동커밋, 수동커밋
    1) Auto Commit 이 기본
    2) 자동 커밋 - 명령 실행 후, 자동으로 커밋이 수행 (ROLLBACK 불가)
    3) 수동 커밋 - 명령 실행 후, 명시적으로 COMMIT 또는 ROLLBACK 을 입력

7. Tx 의 Isolation Level
    1) 각각의 Tx 을 고립시키는 정도 
        1- Read uncommited
            - 커밋되지 않은 데이터도 읽기 가능
            - 트랜잭션에서 처리 중인 아직 commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
            - 격리 수준이 가장 낮은 단계
        2- Read commited
            - 커밋된 데이터만 읽기 가능 (phantom read 유령)
            - 트랜잭션이 commit 확정된 데이터만 다른 트랜잭션이 읽도록 허용
        3- Repeatable read
            - 반복 읽기, Tx 이 시작된 이후 변경은 무시됨.
            - 트랜잭션 내에서 쿼리를 두번 이상 수행할 때, 
              첫번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌는 현상을 방지
        4- Serializable
            - 직렬화
            - 한번에 하나의 Tx 만 독립적으로 수행
            - 직렬화가 될수록 성능은 떨어지고, 품질은 높아짐
                - DBMS 운영시 동시성이 크게 떨어지면서 성능 상 이슈가 발생함
            - 가장 이상적인 격리 수준의 보장 

8. 트랜잭션 요점
    1) 테이블에 데이터의 변경을 발생시키는 입력(INSERT), 수정(UPDATE), 삭제(DELETE),
       수행 시 그 변경되는 데이터의 무결성을 보장하는 것이 커밋(COMMIT)과 롤백(Rollback)의 목적.
    2) 커밋은 "변경된 데이터를 테이블에 영구적으로 반영해라" 라는 의미를 갖는 것
    3) 롤백은 "변경전으로 복귀하라"라는 의미
    4) 저장점(SAVE POINT)은 "데이터 변경을 사전에 지정한 저장점까지만 롤백하라"는 의미
    5) 트랜잭션의 대상이 되는 sql 문장을 실행하면 자동으로 시작되고,
       commit 또는 Rollback 을 실행한 시점에 종료













※ 트랜잭션? 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
            = 질의어(SQL)을 이용, 데이터베이스에 접근하는 것 (=select, insert, delete, update)
    ex) 게시판에서 A이용자가 글을 등록했을 경우
        
        ◎ 올리기 버튼 클릭 = INSERT문을 사용하여 사용자가 입력한 게시그르이 데이터를 옮김
        ◎ 게시판 구성 데이터를 다시 SELECT하여 최신 정보로 유지
        ---------------------------------------------
        INSERT + SELECT = 트랜잭션

    특징 ?
        1) 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다
        2) 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다
        3) 하나의 트랜잭션은 Commit되거나 Rollback된다


    성질 ? 
        1) 원자성(Atomicity)
            = 트랜잭션이 데이터 베이스에 모두 반영되거나 전혀 반영되지 않아야 한다  
              Tx내의 모든 명령은 완벽히 수행되어야 하며, 어느 하나라도 오류가 발생하면 Tx 전부가 취소되어야 함

        2) 일관성(Consistency)
            = 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 함
              시스템이 가지고 있는 고정요소는 Tx 수행 전과 후가 동일해야 함

        3) 독립성(Isolation)
            = 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다
              수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과 참조 불가

        4) 지속성(Durability)
            = 트랜잭션이 성공적으로 완료될 경우 결과는 영구적으로 반영되어야 함

    사용이유 ? 
        = 여러개의 작업을 하나의 논리적인 단위로 묶어 반영과 복구를 조정할 수 있기 위해 사용
        so, 데이터의 부정합이 일어났을 경우 롤백을 하여 데이터의 부정합을 방지할 수 있다
        (데이터의 부정합? = 데이터가 연결되어 있는 메모리 상에서 변경이 되는 경우, 관련된 데이터들을 일괄적으로 값이 일치화 시키는 과정에서 데이터 값이 다른 경우)


    연산 ? 
        1) COMMIT
            = 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때, 하나의 트랜잭션이 끝났다는 것을 알려주기 위한 연산
                └> 수행시 /  수행했던 트랜잭션이 로그에 저장되며, 후에 Rollback 연산을 수행했었던 트랜잭션 단위로 하는 것을 도와줌

        2) ROLLBACK
            = 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진 경우, 트랜잭션을 처음부터 다시 시작하거나 트랜잭션의 부분적으로만 연산된 결과를 다시 취소시킴

    상태 ? 
        1) 활동(Active) : 트랜잭션이 실행중인 상태
        2) 실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태
        3) 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
        4) 부분완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
        5) 완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

        부분완료 vs 완료
            commit 요청이 들어오면 상태는 '부분완료' 상태 -> 문제없이 commit시 '완료'
                                                     -> 오류 발생시 '실패' 상태

    주의사항 ? 
        ◎ 꼭 필요한 최소의 코드에만 적용하는 것이 좋다 (= 트랜잭션의 범위를 최소화 해야 함)
            -> 일반적으로 데이터베이스의 커넥션은 개수가 제한적인데, 각 단위 프로그램이 커넥션을 소유하는 시간이 길어짐 -> 사용 가능한 여유 커넥션의 개수 ↓
        
    


  활동  ┌>  부분완료 -> 완료
    ㅇ  │    ↓
        └  실패 ------> 철회
